import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as l,c as n,b as e,d as t,e as a,w as i,a as d}from"./app-4edf2fa6.js";const r={},h=d('<h1 id="a01-编码风格既江湖规矩" tabindex="-1"><a class="header-anchor" href="#a01-编码风格既江湖规矩" aria-hidden="true">#</a> A01.编码风格既江湖规矩</h1><p>编码风格既是江湖规矩，江湖既是非，历史上这样的争辩非常之多。</p><ul><li>空格和Tab缩进：<code>0x20</code>与<code>0x09</code></li><li><code>}</code>要不要换行：<code>} else {</code>和<code>else {</code>和<code>else</code></li><li>大小写，等号对齐等。</li></ul><p>总之，一个项目（最好一个团队），只能保持唯一规矩，没有优劣之分。 重点在于Commit或Review时，不能因为排版不同而引发Diff和Merge。</p>',4),_={id:"a01a-默认wingsboot风格可选",tabindex:"-1"},p=e("a",{class:"header-anchor",href:"#a01a-默认wingsboot风格可选","aria-hidden":"true"},"#",-1),u=d("<p>在不同项目的Review中，会遵循该项目的编码风格，我的IDE默认是<code>wings-idea-style.xml</code></p><ul><li>180字提醒，220字断行，鼓励长命名。</li><li>单行短<code>if</code>，以节省行空间。</li><li><code>xxx {</code>，方便按行操作，整块注释或复制。</li><li>留有空白，但不留太长大多空白。</li><li>以明确的命名，取代无意义的机械注释。</li></ul>",2),f={id:"a01b-方法行数2屏推荐",tabindex:"-1"},v=e("a",{class:"header-anchor",href:"#a01b-方法行数2屏推荐","aria-hidden":"true"},"#",-1),x=e("p",null,"一个方法多少行舒服，和脑力能压入多少栈有关，一般2屏可以接受，3屏要来回滚动。 一屏多大呢？在1080P显示器内，大概40行代码，因此2屏大概120行，3屏大概180行。",-1),g=e("p",null,[t("方法中，整块的"),e("code",null,"set(get())"),t("，可以视为一个有效行，或干脆提取为Mapper方法。 对于行数较多的大方法，应该拆分或提取成有具体功能的小方法的组合。")],-1),b={id:"a01c-方法参数5个推荐",tabindex:"-1"},m=e("a",{class:"header-anchor",href:"#a01c-方法参数5个推荐","aria-hidden":"true"},"#",-1),y=e("p",null,"参数列表建议3个以内，不超过5个。即便有类型校验的多参数，也不好辨识或错误输入。",-1),A=e("p",null,"private方法，可以放宽限制，而非private方法，在建议合并参数为一个输入类。",-1),w={id:"a01d-泛型参数3个推荐",tabindex:"-1"},B=e("a",{class:"header-anchor",href:"#a01d-泛型参数3个推荐","aria-hidden":"true"},"#",-1),C=e("p",null,"目前Java(8-17)的类型系统仍有很大的历史包袱，相比于其他语音很不完备。",-1),E=e("p",null,"泛型要考虑类型的不变/invariance，协变/covariance，逆变/contravariance。",-1),N={id:"a01e-类内成员10个推荐",tabindex:"-1"},S=e("a",{class:"header-anchor",href:"#a01e-类内成员10个推荐","aria-hidden":"true"},"#",-1),V=e("p",null,"一个类的成员（Field/Method）种类或及数量都不应该过多，容易破坏单一职责或封装。 具有相同模式（如多态方法）或识别度（如同规则注入）的成员，可以视为一种。",-1),k={id:"a01f-继承关系3代推荐",tabindex:"-1"},D=e("a",{class:"header-anchor",href:"#a01f-继承关系3代推荐","aria-hidden":"true"},"#",-1),L=e("p",null,"继承关系是从集体认同的设计分层算起，比如Service层设计，不包括框架层接口， 而当设计框架时，要从框架的模块起点算起。 避免多层Override，多层super.Invoke。",-1),M={id:"a01g-内联表达式3个推荐",tabindex:"-1"},R=e("a",{class:"header-anchor",href:"#a01g-内联表达式3个推荐","aria-hidden":"true"},"#",-1),F=e("p",null,"内联(inline)的表达式过计算部过多，会造成不必要的脑力浪费。 可把相关计算提取为有明确含义的变量，然后组合变量语义变换。",-1),I={id:"a01h-方法签名宽进严出推荐",tabindex:"-1"},T=e("a",{class:"header-anchor",href:"#a01h-方法签名宽进严出推荐","aria-hidden":"true"},"#",-1),G=d("<p><code>宽进</code>指输入参数，使用最大类型，满足使用时，越抽象宽松越好。 <code>严出</code>指返回值，使用小类型，同输入相反，越具体严谨越好。</p><p>以下类型的顺序为从严谨到宽松，从具体到抽象，从小到大。</p><ul><li><code>ArrayList&lt;String&gt;</code> 具体容器，具体元素</li><li><code>ArrayList&lt;E&gt;</code> 具体容器，泛型元素</li><li><code>List&lt;E&gt;</code> 接口容器，泛型元素</li><li><code>Collection&lt;E&gt;</code> 更抽象容器</li><li><code>Collection&lt;? extend E&gt;</code> 更抽象接口，更宽松的类型协变</li></ul>",3);function H(J,O){const o=s("Badge");return l(),n("div",null,[h,e("h2",_,[p,t(" A01A.默认WingsBoot风格"),a(o,{type:"note",vertical:"top"},{default:i(()=>[t("可选")]),_:1})]),u,e("h2",f,[v,t(" A01B.方法行数2屏"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),x,g,e("h2",b,[m,t(" A01C.方法参数5个"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),y,A,e("h2",w,[B,t(" A01D.泛型参数3个"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),C,E,e("h2",N,[S,t(" A01E.类内成员10个"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),V,e("h2",k,[D,t(" A01F.继承关系3代"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),L,e("h2",M,[R,t(" A01G.内联表达式3个"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),F,e("h2",I,[T,t(" A01H.方法签名宽进严出"),a(o,{type:"tip",vertical:"top"},{default:i(()=>[t("推荐")]),_:1})]),G])}const j=c(r,[["render",H],["__file","a01-read-code-style.html.vue"]]);export{j as default};
